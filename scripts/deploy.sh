#!/usr/bin/env bash
set -eo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
ENV_FILE="$PROJECT_DIR/.env"

# ---------------------------------------------------------------------------
# Check if a port is available
# ---------------------------------------------------------------------------
port_free() {
  local port="$1"
  # Method 1: try to actually bind the port (most reliable, works on macOS + Linux)
  if command -v python3 > /dev/null 2>&1; then
    python3 -c "
import socket, sys
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
try:
    s.bind(('0.0.0.0', int(sys.argv[1])))
    s.close()
    sys.exit(0)
except OSError:
    s.close()
    sys.exit(1)
" "$port" 2>/dev/null
    return $?
  fi
  # Method 2: lsof fallback
  if command -v lsof > /dev/null 2>&1; then
    ! lsof -iTCP:"$port" -sTCP:LISTEN -P -n > /dev/null 2>&1
    return $?
  fi
  # Method 3: ss/netstat fallback
  if command -v ss > /dev/null 2>&1; then
    ! ss -tlnp 2>/dev/null | grep -q ":${port} "
    return $?
  fi
  if command -v netstat > /dev/null 2>&1; then
    ! netstat -tlnp 2>/dev/null | grep -q ":${port} "
    return $?
  fi
  return 0
}

# ---------------------------------------------------------------------------
# Find the next free port starting from a given port
# ---------------------------------------------------------------------------
find_free_port() {
  local port="$1"
  local max=$((port + 100))
  while [ "$port" -lt "$max" ]; do
    if port_free "$port"; then
      echo "$port"
      return 0
    fi
    port=$((port + 1))
  done
  echo ""
  return 1
}

# ---------------------------------------------------------------------------
# Resolve a single port: use default if free, otherwise find next free
# ---------------------------------------------------------------------------
CONFLICTS=0

resolve_port() {
  local label="$1"
  local env_key="$2"
  local default="$3"

  if port_free "$default"; then
    printf "    %-25s :%s  available\n" "$label" "$default"
    echo "${env_key}=${default}" >> "$ENV_FILE"
  else
    local free
    free=$(find_free_port $((default + 1))) || true
    if [ -n "$free" ]; then
      printf "    %-25s :%s  in use -> remapped to :%s\n" "$label" "$default" "$free"
      echo "${env_key}=${free}" >> "$ENV_FILE"
      CONFLICTS=$((CONFLICTS + 1))
    else
      echo "    ERROR: Could not find a free port near $default for $label"
      exit 1
    fi
  fi
}

# ---------------------------------------------------------------------------
# Check all ports and auto-resolve conflicts
# ---------------------------------------------------------------------------
# Stop any existing containers from a previous run (frees their ports)
echo "==> Stopping any existing containers..."
cd "$PROJECT_DIR"
docker compose down --remove-orphans > /dev/null 2>&1 || true

echo "==> Checking port availability..."

echo "# Auto-generated by deploy.sh â€” port assignments" > "$ENV_FILE"

resolve_port "Pyroscope"             PYROSCOPE_PORT             4040
resolve_port "Prometheus"            PROMETHEUS_PORT            9090
resolve_port "Grafana"               GRAFANA_PORT               3000
resolve_port "API Gateway"           API_GATEWAY_PORT           8080
resolve_port "Order Service"         ORDER_SERVICE_PORT         8081
resolve_port "Payment Service"       PAYMENT_SERVICE_PORT       8082
resolve_port "Fraud Service"         FRAUD_SERVICE_PORT         8083
resolve_port "Account Service"       ACCOUNT_SERVICE_PORT       8084
resolve_port "Loan Service"          LOAN_SERVICE_PORT          8085
resolve_port "Notification Service"  NOTIFICATION_SERVICE_PORT  8086

if [ "$CONFLICTS" -gt 0 ]; then
  echo ""
  echo "    Resolved $CONFLICTS port conflict(s). Ports saved to .env"
fi

echo ""

# ---------------------------------------------------------------------------
# Build and start
# ---------------------------------------------------------------------------
echo "==> Building and starting all services..."
cd "$PROJECT_DIR"
docker compose build --parallel
docker compose up -d

echo ""
echo "==> Waiting for services to become healthy..."
for svc in pyroscope prometheus grafana api-gateway order-service payment-service fraud-service account-service loan-service notification-service; do
  printf "    %-25s" "$svc"
  for attempt in $(seq 1 30); do
    if docker compose ps "$svc" 2>/dev/null | grep -q "Up"; then
      echo "UP"
      break
    fi
    sleep 2
    if [ "$attempt" -eq 30 ]; then
      echo "TIMEOUT â€“ check logs with: docker compose logs $svc"
    fi
  done
done

# ---------------------------------------------------------------------------
# Print URLs using actual assigned ports
# ---------------------------------------------------------------------------
set -a
. "$ENV_FILE"
set +a

echo ""
echo "==> Bank Enterprise Services:"
echo "    Grafana:        http://localhost:${GRAFANA_PORT}  (admin/admin)"
echo "    Pyroscope:      http://localhost:${PYROSCOPE_PORT}"
echo "    Prometheus:     http://localhost:${PROMETHEUS_PORT}"
echo "    API Gateway:    http://localhost:${API_GATEWAY_PORT}"
echo "    Order Service:  http://localhost:${ORDER_SERVICE_PORT}"
echo "    Payment Svc:    http://localhost:${PAYMENT_SERVICE_PORT}"
echo "    Fraud Svc:      http://localhost:${FRAUD_SERVICE_PORT}"
echo "    Account Svc:    http://localhost:${ACCOUNT_SERVICE_PORT}"
echo "    Loan Svc:       http://localhost:${LOAN_SERVICE_PORT}"
echo "    Notification:   http://localhost:${NOTIFICATION_SERVICE_PORT}"
echo ""
echo "==> Generate load with:  bash scripts/generate-load.sh"
